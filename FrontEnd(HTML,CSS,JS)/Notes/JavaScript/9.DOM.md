HTML 页面中，文档元素始终都是元素。在 XML 中，没有预定义
的元素，因此任何元素都可能成为文档元素。

# Node 类型

* Node.ELEMENT_NODE(1)；
* Node.ATTRIBUTE_NODE(2)；
* Node.TEXT_NODE(3)；
* Node.CDATA_SECTION_NODE(4)；
* Node.ENTITY_REFERENCE_NODE(5)；
* Node.ENTITY_NODE(6)；
* Node.PROCESSING_INSTRUCTION_NODE(7)；
* Node.COMMENT_NODE(8)；
* Node.DOCUMENT_NODE(9)；
* Node.DOCUMENT_TYPE_NODE(10)；
* Node.DOCUMENT_FRAGMENT_NODE(11)；
* Node.NOTATION_NODE(12)。

每个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。

NodeList 是一种类数组对象，它实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映在 NodeList 对象中。我们常说，NodeList 是有生命、有呼吸的对象，而不是在我们第一次访问它们
的某个瞬间拍摄下来的一张快照。

要了解节点的具体信息，可以使用 nodeName 和 nodeValue 这两个属性。

如果列表中只有一个节点，那么该节点的 nextSibling 和  previousSibling 都为 null。

列表中第一个节点的 previousSibling 属性值为 null，而列表中最后一个节点的 nextSibling 属性的值同样也为 null。

在只有一个子节点的情况下，firstChild 和 lastChild 指向同一个节点。如果没有子节点，那么 firstChild 和 lastChild 的值均为 null。

parentNode：指向文档树中的父节点。

previousSibling/nextSibling：上/下一个兄弟节点。

childNodes： 子节点(类数组)。

firstChild/lastChild：第一个/最后一个子节点。

ownerDocument：指向表示整个文档的文档节点。

>如果传入到 appendChild() 中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置。即使可以将 DOM 树看成是由一系列指针连接起来的，但任何 DOM 节点也不能同时出现在文档中的多个位置上。

parentNode.appendChild()：向 childNodes 列表的末尾添加一个节点，返回新增的节点。

parentNode.insertBefore()：接受两个参数(要插入的节点和作为参照的节点)。

> 插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是 null，则 insertBefore() 与 appendChild() 执行相同的操作。

parentNode.replaceChild()：接受的两个参数是(要插入的节点和要替换的节点)。

> 该节点的所有关系指针都会从被它替换的节点复制过来。尽管从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置。

parentNode.removeChild()：接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值。

> 与使用 replaceChild()方法一样，通过 removeChild()移除的节点仍然为文档所有，只不过在
> 文档中已经没有了自己的位置。

