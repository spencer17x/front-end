# 区分大小写

ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。这也就意味着，变量名 test 和变量名 Test 分别表示两个不同的变量，而函数名不能使用 typeof，因为它是一个关键字，但 typeof 则完全可以是一个有效的函数名。

# 标识符

所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则组合起来的一或多个字符：

  第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；

  其他字符可以是字母、下划线、美元符号或数字。 标识符中的字母也可以包含扩展的 ASCII 或 Unicode 字母字符（如 À 和 Æ），但我们不推荐这样做。 按照惯例，ECMAScript 标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写。

不能把关键字、保留字、true、false 和 null 用作标识符。 

# 关键字和保留字

关键字（带*号上标的是第 5 版新增的关键字）： 

| break      | do       | instanceof | typeof |
| ---------- | -------- | ---------- | ------ |
| case       | else     | new        | var    |
| catch      | finally  | return     | void   |
| continue   | for      | switch     | while  |
| debugger * | function | this       | with   |
| default    | if       | throw      |        |
| delete     | in       | try        |        |

保留字(尽管保留字在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字，以下是第 3 版定义的全部保留字):

| abstract | enum       | int       | short        |
| -------- | ---------- | --------- | ------------ |
| boolean  | export     | interface | static       |
| byte     | extends    | long      | super        |
| char     | final      | native    | synchronized |
| class    | float      | package   | throws       |
| const    | goto       | private   | transient    |
| debugger | implements | protected | volatile     |
| double   | import     | public    |              |

 第 5 版把在非严格模式下运行时的保留字缩减为下列这些： 

| class | enum   | extends | super |
| ----- | ------ | ------- | ----- |
| const | export | import  |       |

在严格模式下，第 5 版还对以下保留字施加了限制： 

| implements | package   | public |
| ---------- | --------- | ------ |
| interface  | private   | static |
| let        | protected | yield  |

注意，let 和 yield 是第 5 版新增的保留字；其他保留字都是第 3 版定义的。为了最大程度地保 证兼容性，建议将第 3 版定义的保留字外加 let 和 yield 作为编程时的参考。 

在实现 ECMAScript 3 的 JavaScript 引擎中使用关键字作标识符，会导致“Identifier Expected”错误。 而使用保留字作标识符可能会也可能不会导致相同的错误，具体取决于特定的引擎。 

第 5 版对使用关键字和保留字的规则进行了少许修改。关键字和保留字虽然仍然不能作为标识符使 用，但现在可以用作对象的属性名。一般来说，最好都不要使用关键字和保留字作为标识符和属性名， 以便与将来的 ECMAScript 版本兼容。 

除了上面列出的保留字和关键字，ECMA-262 第 5 版对 eval 和 arguments 还施加了限制。在严 格模式下，这两个名字也不能作为标识符或属性名，否则会抛出错误。 

# 变量

如果在函数中使用 var 定义一个变量，那么这个变量在函数退出后就会被销毁。

> 虽然省略 var 操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局 部作用域中定义的全局变量很难维护，而且如果有意地忽略了 var 操作符，也会由于 相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式 下会导致抛出 ReferenceError 错误。 

# 数据类型

基本数据类型(简单数据类型/原始值): Undefined、Null、Boolean、Number、String和Symbol(ES6新增)。

复制数据类型(引用值): Object。

> typeof 是一个操作符而不是函数，typeof null 返回 "object"。Safari 5 及之前版本、Chrome 7 及之 前版本在对正则表达式调用 typeof 操作符时会返回"function"，而其他浏览器在这种情况下会返回 "object"。
>
>  从技术角度讲，函数在 ECMAScript 中是对象，不是一种数据类型。然而，函数也 确实有一些特殊的属性，因此通过 typeof 操作符来区分函数和其他对象是有必要的。 

对于尚未声明过的变量，只 能执行一项操作，即使用 typeof 操作符检测其数据类型（对未经声明的变量调用 delete 不会导致错 误，但这样做没什么实际意义，而且在严格模式下确实会导致错误）。 

对未初始化的变量执行 typeof 操作符会返回 undefined 值，而对未声明的变量执行 typeof 操作符同样也会返回 undefined 值。 

> null == undefined 返回 true。

null 值表 示一个空对象指针，实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true。

如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。 

这样 一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用 。

只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以 体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。 

## Number类型

最基本的数值字面量格式是十进制整数

除了以十进制表示外，整数还可以通过八进制（以 8 为基数）或十六进制（以 16 为基数）的字面值 来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0～7）。如果字面值中的 数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。 

八进制字面量在严格模式下是无效的，会导致支持的 JavaScript 引擎抛出错误。 

十六进制字面值的前两位必须是 0x，后跟任何十六进制数字（0～9 及 A～F）。其中，字母 A～F 可以大写，也可以小写。 

在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。 

> 鉴于 JavaScript 中保存数值的方式，可以保存正零（+0）和负零（-0）。正零和负零被认为全等 ，即 +0 === -0 返回 true。

浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。 

> 关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于 IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家；其他使用相同数值格 式的语言也存在这个问题。 

Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；能够表示的最大数值保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。如果某次计算的 结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具 体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转 换成 Infinity（正无穷）。 

如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算， 因为 Infinity 不是能够参与计算的数值。要想确定一个数值是不是有穷的（换句话说，是不是位于最 小和最大的数值之间），可以使用 isFinite() 函数。这个函数在参数位于最小与最大数值之间时会返回 true。

> 访问 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以 得到负和正 Infinity 的值。可以想见，这两个属性中分别保存着-Infinity 和 Infinity。 

> NaN == NaN 返回 false。
>
> isNaN(NaN) 返回 true。

> 0 除以 0 返回 NaN，正数除以 0 返回 Infinity，负数除以 0 返回-Infinity。 

> isNaN() 确实也适用于对象。在基于对象调用 isNaN() 函数时，会首先调用对象的 valueOf() 方法，然后确定该方法返回的值是否可以转 换为数值。如果不能，则基于这个返回值再调用 toString() 方法，再测试返回值。 

## 数值转换

### Number() 函数

> Number(null) ==> 0
>
> Number(undefined) ==> NaN

如果是字符串，遵循下列规则： 

* 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1" 会变成 1，"123"会变成 123，而"011"会变成 11（注意：前导的零被忽略了）； 
* 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽 略前导零）； 
* 如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整 数值； 
* 如果字符串是空的（不包含任何字符），则将其转换为 0； 
* 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。 
* 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。 

### parseInt() 函数

会忽略字 符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt() 就会返回 NaN；也就是说，用 parseInt()转换空字符串会返回 NaN（Number()对空字符返回 0）。如 果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了 一个非数字字符。 

如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式（即前面讨论的 十进制、八进制和十六进制数）。也就是说，如果字符串以"0x"开头且后跟数字字符，就会将其当作一 个十六进制整数；如果字符串以"0"开头且后跟数字字符，则会将其当作一个八进制数来解析。 

可以为这个函数提供第二个参数：转换 时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数 16 作为第 二个参数，可以保证得到正确的结果 

### parseFloat() 函数

与 parseInt()函数类似，parseFloat()也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第 一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说， "22.34.5"将会被转换为 22.34。 

除了第一个小数点有效之外，parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导 的零。parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格 式的字符串则始终会被转换成 0。由于 parseFloat()只解析十进制值，因此它没有用第二个参数指定基 数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。 

## toString() 函数

在调用数值的 toString()方法时，可以传递一个参数：输出数值的基数。默认情况下，toString()方法以十进制格式返回数值的字符串表示。而通过传递基数，toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。 

null 和 undefined 没有 toString()方法 

# switch语句

switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如， 字符串"10"不等于数值 10）。 

# 函数

由于不存在函数签名的特性，ECMAScript 函数不能重载。 

ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。 

在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。但在 ECMAScript 中，没有这些条条框框，解析器不会验证命名参数。 

