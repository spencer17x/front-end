# window 对象

全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。

```javascript
var age = 29;
window.color = "red";
//在 IE < 9 时抛出错误，在其他所有浏览器中都返回 false
delete window.age;
//在 IE < 9 时抛出错误，在其他所有浏览器中都返回 true
delete window.color; //returns true
alert(window.age); //29
alert(window.color); //undefined 
```

刚才使用 var 语句添加的 window 属性有一个名为 [[Configurable]] 的特性，这个特性的值被设置为 false，因此这样定义的属性不可以通过delete操作符删除。IE8 及更早版本在遇到使用delete 删除 window 属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9 及更高版本不会抛出错误。 

> Windows Mobile 平台的 IE 浏览器不允许通过 window.property = value 之类的形式，直接在 window 对象上创建新的属性或方法。可是，在全局作用域中声明的所有变量和函数，照样会变成 window 对象的成员。 

如果页面中包含框架，则每个框架都拥有自己的 window 对象，并且保存在 frames 集合中。在 frames 集合中，可以通过数值索引（从 0 开始，从左至右，从上到下）或者框架名称来访问相应的 window 对 象。每个 window 对象都有一个 name 属性，其中包含框架的名称。 

top 对象始终指向最高（最外）层的框架，也就是浏览器窗口。使用它可以确保在一个 框架中正确地访问另一个框架。因为对于在一个框架中编写的任何代码来说，其中的 window 对象指向的都是那个框架的特定实例，而非最高层的框架。 

与 top 相对的另一个 window 对象是 parent。顾名思义，parent（父）对象始终指向当前框架的直接上层框架。在某些情况下，parent 有可能等于 top；但在没有框架的情况下，parent 一定等于 top（此时它们都等于 window）。 

注意，除非最高层窗口是通过 window.open()打开的，否则其 window 对象 的 name 属性不会包含任何值。 

与框架有关的最后一个对象是 self，它始终指向 window；实际上，self 和 window 对象可以互 换使用。引入 self 对象的目的只是为了与 top 和 parent 对象对应起来，因此它不格外包含其他值。 

所有这些对象都是 window 对象的属性，可以通过 window.parent、window.top 等形式来访问。 同时，这也意味着可以将不同层次的window 对象连缀起来，例如window.parent.parent.frames[0]。 

> 在使用框架的情况下，浏览器中会存在多个 Global 对象。在每个框架中定义的 全局变量会自动成为框架中 window 对象的属性。由于每个 window 对象都包含原生 类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应， 但并不相等。例如，top.Object 并不等于 top.frames[0].Object。这个问题会 影响到对跨框架传递的对象使用 instanceof 操作符。 

## 窗口位置

用来确定和修改 window 对象位置的属性和方法 ：

IE/Safari/Opera/Chrome：screenLeft 、screenTop (用于表示窗口相对于屏幕左边和上边的位置 )。

Firefox：screenX、screenY(Safari 和 Chrome 也同时支持这两个属性，Opera 虽然也支持 screenX 和 screenY 属性，但与 screenLeft 和 screenTop 属性并不对应 )。

在 IE、Opera 中，screenLeft 和 screenTop 中保存 的是从屏幕左边和上边到由 window 对象表示的页面可见区域的距离。 

在 Chrome、Firefox和 Safari中，screenY 或 screenTop 中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的 y 轴坐标为 0 时返回 0。 

moveTo() 接收的是新位置的 x 和 y 坐标值，而 moveBy() 接收的是在水平和垂直方向上移动的像素数。 

> 需要注意的是，这两个方法可能会被浏览器禁用；而且，在 Opera 和 IE 7（及更高版本）中默认就是禁用的。另外，这两个方法都不适用于框架，只能对最外层的 window 对象使用。 

## 窗口大小

IE9+、Firefox、Safari、Opera 和 Chrome：innerWidth、innerHeight、outerWidth 和 outerHeight。 

在 IE9+、Safari 和 Firefox 中，outerWidth 和 outerHeight 返回浏览器窗口本身的尺寸。

在 Opera中，这两个属性的值表示页面视图容器的大小。 (这里所谓的“页面视图容器”指的是 Opera 中单个标签页对应的浏览器窗口)。而 innerWidth 和 innerHeight 则表示该容器中页面视图区的大小（减去边框宽度）。 

 Chrome 中，outerWidth、outerHeight 与 innerWidth、innerHeight 返回相同的值，即视口（viewport）大小而非浏览器窗口大小。 

> IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过 DOM 提供了页面可见区域 的相关信息。

在 IE、Firefox、Safari、Opera 和 Chrome 中，document.documentElement.clientWidth 和 document.documentElement.clientHeight 中保存了页面视口的信息。在 IE6 中，这些属性必须在 标准模式下才有效；如果是混杂模式，就必须通过 document.body.clientWidth 和 document.body. clientHeight 取得相同信息。而对于混杂模式下的 Chrome，则无论通过 document.documentElement 还是 document.body 中的 clientWidth 和 clientHeight 属性，都可以取得视口的大小。 

使用 resizeTo()和 resizeBy()方法可以调整浏览器窗口的大小。 

> 需要注意的是，这两个方法与移动窗口位置的方法类似，也有可能被浏览器禁用；而且，在 Opera 和 IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的 window 对象使用。 

window.open()：接收 4 个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览 器历史记录中当前加载页面的布尔值。 通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。 

> 在打开计算机硬盘中的网页时，IE 会解除对弹出窗口的某些限制。但是在服务器 上执行这些代码会受到对弹出窗口的限制。 

大多数浏览器都内置有弹出窗口屏蔽程序，而没有内置此类程序的浏览器，也可以安装 Yahoo! Toolbar 等带有内置屏蔽程序的实用工具。结果就是用户可以将绝大多数不想看到弹出窗口屏蔽掉。于 是，在弹出窗口被屏蔽时，就应该考虑两种可能性。如果是浏览器内置的屏蔽程序阻止的弹出窗口，那 么 window.open()很可能会返回 null。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽 了，如下面的例子所示。 

```javascript
var wroxWin = window.open("http://www.wrox.com", "_blank");
if (wroxWin == null){
	alert("The popup was blocked!");
} 
```

如果是浏览器扩展或其他程序阻止的弹出窗口，那么 window.open()通常会抛出一个错误。因此， 要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对 window.open() 的调用封装 在一个 try-catch 块中 

```javascript
var blocked = false;
try {
    var wroxWin = window.open("http://www.wrox.com", "_blank");
    if (wroxWin == null){
    	blocked = true;
    }
} catch (ex) {
    blocked = true;
}
if (blocked){
	alert("The popup was blocked!");
} 
```

