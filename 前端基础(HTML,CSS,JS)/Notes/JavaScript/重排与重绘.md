# 重排和重绘

**重排**是指浏览器布置页面的过程。当你第一次显示 DOM 时（通常是在 DOM 和 CSS 加载之后）会发生重排，而且每当某个操作会导致布局改变时，都会再次发生重排。这是一个*代价很高*（缓慢）的过程。

**重绘**发生在重排之后，是指浏览器将新布局绘制到屏幕上的过程。它相对较快，但我们还是想限制它发生的频率。

例如，如果你将一个 CSS 类添加到一个元素中，浏览器往往会重新计算整个页面的布局——即执行一次重排和一次重绘！

重排是计算页面元素的尺寸和位置的过程。这是一个计算密集（缓慢）的任务。重绘是将像素绘制到屏幕上的过程。它比重排要快，但仍然不是一个快速的过程。你要确保你的代码尽可能少地引起重排。

# 调用栈

调用栈是解析器(如浏览器中的的javascript解析器)的一种机制，可以在脚本调用多个 [函数](https://developer.mozilla.org/en-US/docs/Glossary/function) 时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数正在执行，什么函数被这个函数调用，下一个调用的函数是谁）

- 当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。
- 任何被这个函数调用的函数会进一步添加到调用栈中，并且运行到它们被上个程序调用的位置。
- 当函数运行结束后，解释器将它从堆栈中取出，并在主代码列表中继续执行代码。
- 如果栈占用的空间比分配给它的空间还大，那么则会导致“堆栈溢出”错误。

# 事件循环

Javascript 的*并发模型*最简单的解释是使用两条规则： 如果某些 Javascript 正在运行，则让其运行，直到其完成（“运行至完成”）。 如果没有 Javascript 正在运行，则运行任何等待的事件处理器。

由于大多数 Javascript 都是为了响应事件而运行的，因此这被称为*事件循环*：获取下一个事件，运行其处理器，然后重复。

围绕事件循环，你必须考虑三个部分：

- 调用堆栈
- Web API/浏览器
- 事件队列

```js
console.log('howdy'); // 1
document.addEventListener('click', // 2
  function numbers() {
    console.log('123');
});
console.log('ice cream is tasty'); // 3
```

首先，浏览器会运行这个代码块直到完成，即步骤 1、2 和 3。第 2 步会传递一个事件处理器 (`numbers`) 到浏览器中，以备后用：浏览器将保留这个函数，直到发生点击事件。

如果在这段代码完成之前有人点击页面，会发生什么？当有一个点击事件，同时仍有代码正在运行时，`numbers` 函数无法被直接添加到调用堆栈中，这是由于 JavaScript 的运行至完成特性；我们不能打断任何可能正在发生的代码。因此，这个函数将被放置在队列中。当调用堆栈中的所有函数均已完成时（也称为*空闲时间*），则会检查队列，以查看是否有任何内容正在等待。如果队列中有任务，则会运行，并在调用堆栈上创建一个条目。

重要提示：这里要记住的关键点是 1) 当前的同步代码将会运行至完成，而且 2) 事件将在浏览器不繁忙时进行处理。异步代码（如加载图像）在此循环之外运行，并在完成时发送事件。

异步代码使用 JavaScript 事件循环。任何异步代码（如 `setTimeout` 或传递给 `.addEventListener()` 的函数）均由浏览器处理。当异步代码准备好执行时，它会被移到队列中，等待直到调用堆栈为空。一旦调用堆栈为空，代码将从队列移到调用堆栈，并被执行。

